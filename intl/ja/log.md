format
### hoge日目: 2022-mm-dd

**今日の進捗**

**思ったこと・わかったこと**

# 100 Days Of Code - 学習ログ

### 0日目: 2022年11月24日

**今日の進捗**: 
「りあくと！」を読み始めた。
基本情報の試験も終わったのでやっとコードを書く時間が取れそう。
100DaysOfCodeの取り組みも始めてみた。

**思ったこと・わかったこと** 
- Node.jsとは
  -  PC のターミナル上で 実行できる環境を提供するソフトウェア
-  フロントエンド開発にNodeが必要な理由
  - パフォーマンス最適化のために JavaScript や CSS ファイルを少数のファイルにまとめる(=バンドル)
  - 新しいバージョンの JavaScript や AltJS12 のコードを古いバージョンの JavaScript コンパイルして、古いブラウザでも動作可能にする
  - 開発環境においてブラウザにローカルファイルを直接読み込ませるのではなく、ローカルに開発用のアプリ ケーションサーバを稼働させることで、動作を検証しやすくし開発効率を高める
  - テストツールを用いてユニットテストや E2E テスト 13 を記述・実行する
  - ソースコードの静的解析や自動整形を行う
- asdfを使って他の言語環境も管理する
  - brew install asdf
- `.default-npm-packages`の役割
  - 任意のNodeのバージョンをインストールしたときにデフォルトでインストールされるnpmパッケージを登録しておける

**リンク**
- [りあクト！ TypeScriptで始めるつらくないReact開発 第4版【① 言語・環境編】 - くるみ割り書房 ft. React - BOOTH](https://oukayuka.booth.pm/items/2368045)
- [#100DaysOfCode Official Website | #100DaysOfCode](https://www.100daysofcode.com/)

### 1日目: 2022年11月25日

**今日の進捗**: 2-1-2. 年々進化していく JavaScript まで

**思ったこと・わかったこと**
- Viteでプロジェクトを作成する
    - viteを使うことで面倒な設定不要でプロジェクトをつくることができる
      - `rails new`と似たやつ
    - `yarn create vite hello-world --template=react-ts`
    - `--template`でプロジェクトのテンプレートを指定する
    - 今回はReact+TypeScriptのテンプレートを選択している
    - viteはReactだけでなくVueなどの他のフレームワークのプロジェクトも作ることができる
    - yarn を実行
      - yarn install では, package.jsonに記述されている依存パッケージを`node_modules/`配下にインストールして, さらにイン ストールされたパッケージのバージョン情報を、その依存関係も含めて`yarn.lock`というファイルに出力する
      - yarn.lock
        - インストールしたパッケージの依存情報を保存しておくためのファイル
      - リポジトリには`node_modules/`は入れないけど、`yarn.lock`は必ず入れておく\
    - Hot Module Replacement
      - ソースコードを変更・保存するとアプリケーションに即座に反映される
      - Viteの機能のひとつ
    - npm と yarn
      - 後発のyarnがだんだん使われるようになってきた
      - 依存パッケージのバージョン固定ができるyarn.lockが最初から備わっていた
      - Workspace: 複数のプロジェクトを単一のリポジトリで管理するための機能もあった
    - package,json内のdependenciesとdevDependencies
    - devDependencies: 開発環境でしか有効にならない。開発ツールのパッケージを入れる
    - dependencies: 
  -  そもそもJavaScriptについて
    - ES2015以降をモダンJSという

### 2日目: 2022年11月26日

**今日の進捗**: 2-3-3. オブジェクト型とそのリテラル 途中まで  
今日も一時間進めた。途中眠くてあまり集中できなかったので明日また読む。

**思ったこと・わかったこと**
- 変数の宣言
- 変数の宣言には const letを使う
- varの危険性
  - 再宣言再代入が可能
  - 変数の参照が巻き上げられる(hoisting)
    - 変数を宣言する前に値を代入できること
  - スコープの単位が関数
- JavaScriptのデータ型
  - JSにおけるプリミティブ型
  - 静的型付け言語と動的型付け言語
  - どちらもデータ値そのものに型がある
  - 静的型付け言語は変数や関数の引数及び戻り値の型がプログラム実行前に予め決まっている
  - 動的型付け言語はそれらが実行時の値によって動的に変化する
- JavaScriptとTypeScriptの挙動の違い

```
❯ node
Welcome to Node.js v19.1.0.
Type ".help" for more information.
> let num = 100;
undefined
> num = 'foo'
'foo'

❯ ts-node
> let num: number = 100;
undefined
> num = 200
200
// letを宣言しているのに異なるデータ型なのでエラーとなる
> num = 'foo'
<repl>.ts:6:1 - error TS2322: Type 'string' is not assignable to type 'number'.

6 num = 'foo'
  ~~~
```

- JavaScriptにはプリミティブ型とオブジェクト型の2つに大別だれる
- プリミティブというのは、オブジェクトではない、インスタンスメソッドを持たないデータであるということ
- JavaScriptの7つのプリミティブ型
  - Boolean型, Number型, Blight型, String型, Symbol型, Null型, Undefined型
- falsyな値: false, 0, NaN, '', null, undefined
  - これら以外はすべてtruthy

- 2-3-2 プリミティブ値のリテラルとラッパーオブジェクト
  - プリミティブ型の値を定義するには、リテラルを使う
  - リテラル: ソースコードに数値や文字列をベタ書きしてその値を表現する式
  - undefinedはリテラルではなく、プリミティブ値undefinedが格納されているundefinedという名前のグローバル変数

- 2-3-3 オブジェクト型とそのリテラル
  - オブジェクト型にもリテラルを持つものがある
  - 配列リテラル: [1, 2, 3]
  - オブジェクトリテラル
  - 正規表現リテラル

### 3日目: 2022年11月27日

**今日の進捗** 2-4-1. 関数宣言と関数式 まで

**思ったこと・わかったこと**
### Day003
- 2-4-1 関数宣言と関数式
- 文と式
- 文: 何らかの手続を処理系に命令するもの = 変数に代入できる
- 式: 評価された後に値として存在するもの = 変数に代入できない
- JSでは関数は久美子未オブジェクト`Function`のインスタンスであり、第一級オブジェクトでもある
- 第一級オブジェクト
  - 他のオブジェクト型の値と同様に、変数へ代入したり、配列の要素やオブジェクトのプロパティ値にし
たり、他の関数に引数として渡したり、別の関数の戻り値として設定できたりする
- 第一級関数: 関数を第一級オブジェクトとして扱うことができるプログラミング言語の性質
- **インスタンスとは**
  - クラスをもとにつくられたデータのかたまり
- JSにおける関数式とは、Functionオブジェクトを生成するリテラルである
- オブジェクトとかプロパティとかインスタンスとかが出てきて、ぱっと思い出せないので基礎やるためにJS primer読み直そうと思う

### 4日目: 2022-11-28

**今日の進捗** JS Primer 演算子途中まで

**思ったこと・わかったこと**
- りあくと読み始めて、JSの基礎あやふやだな〜と思ったのと、ななめ読みしかしてなかったJS Primerを読み始めた
- 完全に理解してるところは飛ばしつつ、理解があやふやなところはしっかりと。オブジェクトの話とか

#### 以下、JSprimer メモ

- Day004; 2022-11-28
- JavaScriptはECMAScriptという仕様によって動作が決められてる
- JavaScirptは大部分がオブジェクトである
  - オブジェクト: 値や処理を一つにまとめたもの
  - オブジェクトにはECMAScriptの仕様として定められたオブジェクト、実行環境が定義した’オブジェクト、ユーザが定義したオブジェクトが存在する
 
##### 変数と宣言
###### constについて
- const, let, var を使って変数を宣言する
- 変数同士をカンマで区切って、同時に複数の変数を定義できる
 
```js
const bookTitle = "JavaScript Primer"; // constを使った変数定義

const bookTitle = "JavaScript Primer",
      bookCategory = "プログラミング"; // カンマを使ってbookTitleとbookCategoryを同時に定義
```

- constは再代入できない
- 一般的に変数への再代入は「変数の値は最初に定義した値と常に同じである」という**参照透過性**を壊すのでバグを発生點せやすいことでしられている

```js
// constが再代入でエラーになる例
const bookTitle = 'JS Primer'
> bookTitle
'JS Primer'
> bookTitle = 'New Title'
Uncaught TypeError: Assignment to constant variable.
```

###### let
- 値の再代入が可能な変数を宣言できる
- 初期値を指定しない変数も定義できる。この場合はundefinedという値で初期化される

```js
> let bookTitle = 'JavaScript Primer'
undefined
> bookTitle
'JavaScript Primer'
> let bookTitle
Uncaught SyntaxError: Identifier 'bookTitle' has already been declared
> let count = 0
undefined
> count = 1
1
> count= 2
2
> count = 3
3
```

###### var
- 値の再代入が可能な変数を宣言できる
- varには同じ名前の変数を再定義できてしまう問題がある

```js
// letを使って同じ変数名を定義しようとするとエラーになる
> let x;
undefined
> x
undefined
> let x
Uncaught SyntaxError: Identifier 'x' has already been declared

// varではエラーにならない
```js
> var x = 1;
undefined
> var x = 2;
undefined
> x
2
```

- varでは変数の巻き上げが起こる

- 値の評価とは
- 1 + 1 という式を評価したら 2 という結果を返す
- bookTitle という変数を評価したら、変数に代入されている値を返す
- xonst x = 1; という文を評価することで変数を定義するが、この文には返り値はない

# データ型とリテラル
## データ型
- JSは動的型付け言語なので、静的型付け言語のような**変数の型はない**
- しかし、文字列、数値、真偽値といった**値の型**は存在する
  - これらの値の型のことをデータ型という
- データ型には**プリミティブ型**と**オブジェクト**の2つに分けられる
- プリミティブ型は真偽値や数値などの基本的な値の型
- プリミティブ型の値は、イミュータブル特性をもつ
- プリミティブ型ではないものをオブジェクトという
- オブジェクトは複数のプリミティブ型の値またはオブジェクトから成る集合
- オブジェクトはミュータブルな特性をもつ
- オブジェクトは、値そのものではなく値への参照を経由して操作されるため参照型のデータともいう

- 7つのプリミティブ型とオブジェクト
- プリミティブ型
  - 真偽値(Boolean)
  - 数値(Number)
  - 巨大な整数(Bright)
  - 文字列(String)
  - undefined: 値が未定義であることを意味するデータ型
  - null: 値が存在しないことを意味するデータ型
  - Symbol: ES2015から追加された一意で不変な値のデータ型
- オブジェクト
  - **プリミティブ型以外のデータ**
  - オブジェクト、配列、関数、クラス、正規表現、Dateなど
- typeof 演算子を使うことでデータ型を調べることができる

## リテラル
- リテラルとは数値や文字列など、データ型を直接記述できるように構文として定義されたもの

```js
//"と"で囲んだ範囲が文字列リテラル
const str = "こんにちは";
```

- リテラル表現がない場合は、その値を作る関数に引数を渡して作成する
- 冗長になるので、 真偽値 数値 文字列 null の4つのプリミティブ型にはリテラル表現がある
- オブジェクトの中でもよく利用される オブジェクト 配列 正規表現 にはリテラル表現がある

### 真偽値(Boolean)
- true と false のリテラルがある

```node
> true
true
> false
false
```

### 数値(Number)
- 整数リテラルと浮動小数点数リテラルがある
- これらのリテラルで表現できる数値はIEEE 754の倍精度浮動小数として扱われる

#### 整数リテラル
- 10進数, 2進数, 8進数, 16進数 の4種類ある

### テンプレートリテラル
- バッククォートで囲んだ範囲を文字列とするリテラル
- 複数行の文字列を改行記号のエスケープシーケンスを使わずに書くことができる

### undefinedはリテラルではない

- undefinedはただのグローバル変数
- undefinedという名前のローカル変数を宣言できる

```node
function fn(){
    const undefined = "独自の未定義値"; // undefinedという名前の変数をエラーなく定義できる
    console.log(undefined); // => "独自の未定義値"
}
fn();
```

## オブジェクトリテラル
- オブジェクトリテラルは{} を書くことで新しいオブジェクトを作成できる

`const obj = {};`

- オブジェクトリテラルはオブジェクトの作成と同時に中身を定義できる
- オブジェクトのキーと値を:で区切ったものを{}野中に書くことで作成と初期化ができる

```node
const obj = {
  key: "value"
}
```

- **プロパティ**について
  - オブジェクトが持つキーのこと
  - 上記のコードでは、objというオブジェクトはkeyというプロパティを持っているといえる
- objのkeyプロパティを参照するには、ドットでつないで参照する方法とブラケットで参照する方法がある

```node
> const obj = {
... "key": "value"
... };
undefined
> obj.key // .を使った参照
'value'
> obj["key"] // []を使った参照
'value'
```

- ドット記法では、プロパティ名が変数名と同じく識別子である必要があるので、識別子として利用できないプロパティ名はドット記法として書くことができない

### ラッパーオブジェクト
- 真偽値 数値 文字列 はそれぞれリテラルとして表現する方法もある。
- これらはプリミティブ型の値をラップしたようなオブジェクトなのでラッパーオブジェクトという
- **プリミティブ型のデータであってもオブジェクトのようにプロパティ（メソッドなども含む）を参照できる**

### 5日目: 2022-11-29

**今日の進捗** JS Primer 演算子 単項マイナス演算子途中まで

**思ったこと・わかったこと**
#### 単項演算子
##### 単項プラス演算子(`+`)
- オペランドを数値に変換する
- `console.log(+1) // => 1`
- `console.log(+"1") // => 1`
- `console.log(+"文字列") // => NaN 数値に変換できないのでNaNが返る`
- **NaN**とは
  - 数値ではないがNumber型の値
  - NaNはどの値とも位置しない
  - Number.isNaN メソッドを使うことで NaNの判定ができる

```node
> NaN === NaN
false // 自分自身とも一致しない
> typeof NaN
'number' // Number型である
> Number.isNaN(NaN)
true
```

##### 単項マイナス演算子(-)
- マイナスの数値を記述するときに使う
- `console.log(-"1") // => -1` 文字列を数値に変換

### 6日目: 2022-11-30

**今日の進捗** JS Primer 演算子 インクリメント演算子まで

**思ったこと・わかったこと**

##### インクリメント演算子
- ++ はオペランドの数値を+1する演算子
- オペランドの前後どちらかにインクリメント演算子を置くことで、オペランドに対して値を+1した値を返す

```node
> let num = 1
undefined
> num++
1
> num
2
```

- インクリメント演算子はオペランドの後ろに置くか前に置くかで評価の順番が違う
- 後置インクリメント演算子は
  - 1.numの評価結果を返す
  - 2.numに対して+1する
  - という順番で処理を行う
  - ので、num++ の返り値は+1する前の値となる

```node
> let x = 1
undefined
> x++ 
1 // まずxの評価結果を返す
> x
2 // 次にxに+1する
```

- 前置インクリメント演算子は
  - 1.numに対して+1する
  - 2.numの評価結果を返す
  - ので、++numの返り値は+1したあとの値となる

```node
> let y = 1
undefined
> ++y
2
> y
2
```

- 使い分けが必要となる場面は多くないので、評価の順番は異なることだけ覚えておく

### 7日目: 2022-12-01

**今日の進捗** JS Primer 演算子 比較演算子まで

**思ったこと・わかったこと**
#### 比較演算子
- 厳密等価演算子 ===
  - 左右2つのオペランドを比較して、同じ型で同じ値である場合にtrueを返す

```node
> 1 === 1
true
> 1 === '1'
false
```

- オペランドがどちらもオブジェクトのときは、オブジェクトの参照が同じ場合にtrueを返す

```node
// objAとobjBの2つのオブジェクトを作成
> const objA = {};
undefined
> const objB = {};
undefined
// 生成されたオブジェクトは異なる参照となるためfalse
> objA === objB
false
// 同じ参照の比較なのでtrue
> objA === objA
true
>
```

#### 厳密不等価演算子 !==
- 左右2つのオペランドを比較して、異なる型または異なる値である場合にtrueを返す

```node
// 同じNumber型で同じ値なのでfalse
> 1 !== 1
false
// Number型の1とString型の1なのでtrue
> 1 !== '1'
true
```

#### 等価演算子
- 2つのオペランドを比較する。同じデータ型のオペランドを比較する場合は === と同じ結果になる

```node
> 1 ==1
true
> 'str' == 'str'
true
> 'JavaScript' == 'ECMAScript'
false
>
> objA == objB
false
> objA == objA
true
```

- == ではオペランド同士が異なる値だった場合に、同じ型となるように暗黙的な型変換をしてから比較するため、見た目からでは結果を予測できない挙動が存在する

```node
> 1 == '1'
true
> 1 == '01'
true
> 0 == false
true
> 0 == null
false
> null == undefined
true
```
- よって === を使うべき

- nullまたはundefinedの判定したいときには==を使う

```node
const value = undefined; /* または null */
// === では2つの値と比較しないといけない
if (value === null || value === undefined) {
    console.log("valueがnullまたはundefinedである場合の処理");
}
// == では null と比較するだけでよい
if (value == null) {
    console.log("valueがnullまたはundefinedである場合の処理");
}
```
